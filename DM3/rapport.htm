<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<title>IFT3911 - Devoir 3</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" type="text/css" href="./style.css" media="screen">
</head>
<body>

	<h1>IFT3911 - Devoir 3</h1>
	<nav>
		<ul>
			<li><a href="#top">Haut de page</a></li>
			<li><a href="#diag">Design logiciel</a></li>
			<li><a href="#qual">Discussion</a></li>
		</ul>
	</nav>

	<main>

		<div>
			<h2 id="top">Informations générales</h2>
			<div class="student">
				 <dl>
					<dt>Nom:</dt>
					<dd>Félix Bélanger-Robillard</dd>
					<dt>Matricule:</dt>
					<dd>3159</dd>
					<dt>Courriel: </dt>
					<dd>felix.belanger-robillard@umontreal.ca</dd>
					<dt>Temps mis:</dt>
					<dd>14 heures</dd>
				</dl>
			</div>
			<div class="student">
				 <dl>
					<dt>Nom:</dt>
					<dd>Gevrai Jodoin-Tremblay</dd>
					<dt>Matricule:</dt>
					<dd>9650</dd>
					<dt>Courriel:</dt>
					<dd>gevrai.jodoin-tremblay@umontreal.ca</dd>
					<dt>Temps mis:</dt>
					<dd>~15 heures</dd>
				</dl>
			</div>
			<div class="student">
				 <dl>
					<dt>Nom:</dt>
					<dd>Charles Langlois</dd>
					<dt>Matricule:</dt>
					<dd></dd>
					<dt>Courriel: </dt>
					<dd>@umontreal.ca</dd>
					<dt>Temps mis:</dt>
					<dd>14 heures</dd>
				</dl>
			</div>
			<div class="student">
				 <dl>
					<dt>Nom:</dt>
					<dd>François Poitras</dd>
					<dt>Matricule:</dt>
					<dd></dd>
					<dt>Courriel: </dt>
					<dd>@umontreal.ca</dd>
					<dt>Temps mis:</dt>
					<dd>14 heures</dd>
				</dl>
			</div>
		</div>

		<div>
			<h2>Distribution des tâches</h2>

			<table cellpadding="7px">
				<thead>
					<tr>
						<th class="first_col">
							Tâche
						</th>
						<th>
							Félix
						</th>
						<th>
							Gevrai
						</th>
						<th>
							Charles
						</th>
						<th>
							François
						</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td class="first_col">
							Design
						</td>
						<td>
							Discuter trop longtemps de comment gérer les patrons
						</td>
						<td>
							Discuter trop longtemps de comment gérer les patrons,
							Être méticuleux et rendre le tout visuellement potable
						</td>
						<td>Discuter trop longtemps de comment gérer les patrons</td>
						<td>DSS</td>
					</tr>
					<tr>
						<td class="first_col">Code</td>
						<td></td>
						<td>Génération du code, implantation du paquet Travel</td>
						<td>Génération du code</td>
						<td></td>
					</tr>
					<tr>
						<td class="first_col">Autres</td>
						
						<td>Mise en page du rapport, réseau de Pétri, discussion sur la qualité, GUI</td>
						
						<td></td>
						<td></td>
						<td></td>
					</tr>
					
				</tbody>
			</table>

		</div>
		<h2>Hypothèses</h2>
		<ul>
			<li>Considérant que les patrons sont très adaptables, certains ont été modifiés en conséquence, mais demeurent tout de même fidèles au patron de base.</li>
                        <li>Le focus a été mis sur le design et l'implantation, considérant l'ampleur de la tâche, n'a pas pu être complétée intégralement.</li>
		</ul>
		<h2 id="diag">Design logiciel</h2>
                <p>Le fichier principal est <a href="./Design/design.vpp">ici</a></p> 
		<h3>Patron de fabrique</h3>
		<h3>Patron  de Singleton</h3>
		<h3>Patron d'état</h3>
		<h3>Patron de l'observateur</h3>
		<h3>Patron de commande</h3>
		<h3>Patron du visiteur</h3>
		<h3>Diagramme de paquets</h3>
		<h2 id="qual">Discussion sur la qualité</h2>
                <h3>Graphe IA</h3>
                 
                    <figure>
                        <img src="./qual/iaDM2.png" alt="" />
                        <figcaption>Graphe IA du DM2</figcaption>
                     </figure>
                    <figure>
                        <img src="./qual/iaDM3.png" alt="" />
                        <figcaption>Graphe IA du DM3</figcaption>
                     </figure>
                  
                <p>
			Par rapport au graphe IA, le design précédent ne semblait pas montrer de grandes problématiques au niveau du design. Pour ce design-ci, l'analyse d'un tel graphe nous a forcé à nous pencher sur
                        plusieurs paquets qui se retrouvaient dans la zone de la douleur. Deux paquets, Travel.Itineries et Travel.Facilities, faisaient partie de ce lot et nous avons remarqué qu'ils étaient étroitement couplés avec Trip,
                        mais rien d'autres. Notre solution a été de fusionné les paquets, puisque ces éléments n'avaient pas de sens les uns sans les autres. Si on compare les deux graphes, on constate premièrement
                        que le nombre de paquets est beaucoup plus grand. On voit aussi que plusieurs paquets ne sont pas du tout abstraits. En l'occurence, ce sont les paquets Application, Commands, Travel.Forms,
                        Travel. et Travel.Factories qui ne possèdent aucune abstraction. On peut également constater que certains points n'ont bouger, ce sont les rares paquets qui n'ont pas subis de modification, tels que Travel.Place 
                        et Travel.Vehicle. Globalement, on constate que le degré d'abstraction a diminué, de même que le degré d'indépendance, ce qui nous laisse avec un design assez bon, mais plus difficile à implémenter comparativement
                        au précédent.
		</p>
                <p>
                   L'application des patrons de conception s'est montrée très efficace sur le plan du ratio IA, particulièrement le patron de Commande qui crée un paquet très dépendant avec un seul point
                   d'entré par l'utilisation de l'invocateur. Nous avons également ajouté un paquet Application qui est invoqué par la main. Celle-ci sert d'initialisateur principal et sert de lien entre l'UI et
                   le reste du logiciel. De cette façon, Toute forme d'UI peut facilement être remplacé, car il n'y a aucune dépendance directe.
                </p>
                <p>
                    Notre design est un bon exemple du SRP, en général, les méthodes n'ont qu'un point d'accès et font un nombre de choses limitées. La plus grande cause de l'enflement du nombre de classes, mise à part
                    les patrons de conceptions, est la séparation de nos classes pour réduire la responsabilité de chacune. À ce titre, le patron de commande est encore une fois merveilleux pour créer des 
                    controlleurs simples et conserver un faible couplage. Les interfaces que nous utilisions précédemment sont encore présentes et, par leurs responsabilités limitées dès le départ, nous n'avons
                    pas usé du ISP pour les spécialisées. Le DIP est quand même respecté sur ce plan, car la plupart de nos liens de dépendances sont vers les classes abstraites de nos paquets et les versions concrètes
                     sont gérées à partir des Fabriques, ce qui fait en sorte que les dépendances ne sont presque jamais concrètes dans l'entièreté du logiciel. Cela donne un design assez flexible et facilement extensible.
                     Les Fabriques font d'ailleurs en sorte qu'il serait presque trivial d'ajouter un nouveau mode de transport. Avec tout ce qui est déjà présent, peu de choses auraient besoin d'être ajoutées. En respectant 
                     ces principes, nous respectons également le OCP, surtout avec notre soin apporté au respect du DIP.
  
                </p>
		<h2>Génération et implémentation</h2>
		<h2>Réseau de Pétri</h2>
                <img src="./images/pn.png">
                <p>marquage initial [k,0,k,0]. Tous les arcs sont pondérés à 1 sauf deux arcs pondérés à une constante k. </p>
                <ol>
				<li><img src="./images/gak1.png" />	Pour k=1, pour les k > 1, on aura l'option d'approfondir la branche jusqu'à ce que p1 et p3 soient égaux à 0, avec possibilité de franchir t3 à chacune des étapes de la branche pour revenir au marquage précédent.</li>
				
				<li>Prouvez si le réseau est borné. </li>
				
				<li>Déterminez la vivacité des quatre transitions. </li>
				<li>Déterminez si le réseau est conservateur.</li>
				
			</ol>
		<p>
                    
                    
			
                        Pour n'importe quel k > 0, :</br>
                        Si on regarde le AC pour k=1, on voit qu'on peut toujours retourner au marquage précédent à partir du marquage actuel. C'est également le cas pour toutes les valeurs de k subséquentes. À ce titre, le nombre de marquage possible est fonction de K+1 + |M(K-1)|, c'est à dire que M(K-1) est un sous-ensemble de M(K). On peut donc conclure est le réseau est borné, car son AC ne contient pas d'Omega peu un K de valeur quelconque.
			
			Le réseau est borné, mais il n'a aucune configuration d'interblocage, ce qui lui permet de faire une infinité de transitions. À ce titre, l'ensemble des transitions sont L2-vivantes, car aucune des transitions ne peut être faite infiniment, il y a une limite à ce qu'une transition peut être faite avant de devoir passer par une autre.
			[k,0,k,0] t2 [k-1,0,0,1] 
                        Le réseau est conservateur. Le vecteur vertical [1,2,1,k+1] permet d'obtenir une constante sur l'ensemble des marquages du réseau. Par exemple: <br/>
				[1,2,1,k+1] * [k,0,k,0] = k+0+k+0 = 2k <br/>
				[1,2,1,k+1] * [k-1,0,0,1] = (k-1)/2 + k-1 + 0 + 0 + k+1 = 2k
                                
		</p>
	</main>

</body>
</html>
