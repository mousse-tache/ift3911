<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<title>IFT3911 - Devoir 3</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" type="text/css" href="./style.css" media="screen">
</head>
<body>

	<h1>IFT3911 - Devoir 3</h1>
	<nav>
		<ul>
			<li><a href="#top">Haut de page</a></li>
			<li><a href="#diag">Design logiciel</a></li>
			<li><a href="#qual">Discussion</a></li>
		</ul>
	</nav>

	<main>

		<div>
			<h2 id="top">Informations générales</h2>
			<div class="student">
				 <dl>
					<dt>Nom:</dt>
					<dd>Félix Bélanger-Robillard</dd>
					<dt>Matricule:</dt>
					<dd>3159</dd>
					<dt>Courriel: </dt>
					<dd>felix.belanger-robillard@umontreal.ca</dd>
					<dt>Temps mis:</dt>
					<dd>52 heures</dd>
				</dl>
			</div>
			<div class="student">
				 <dl>
					<dt>Nom:</dt>
					<dd>Gevrai Jodoin-Tremblay</dd>
					<dt>Matricule:</dt>
					<dd>9650</dd>
					<dt>Courriel:</dt>
					<dd>gevrai.jodoin-tremblay@umontreal.ca</dd>
					<dt>Temps mis:</dt>
					<dd>+75 heures</dd>
				</dl>
			</div>
			<div class="student">
				 <dl>
					<dt>Nom:</dt>
					<dd>Charles Langlois</dd>
					<dt>Matricule:</dt>
					<dd>0838</dd>
					<dt>Courriel: </dt>
					<dd>schok53@gmail.com</dd>
					<dt>Temps mis:</dt>
					<dd>20 heures</dd>
				</dl>
			</div>
			<div class="student">
				 <dl>
					<dt>Nom:</dt>
					<dd>François Poitras</dd>
					<dt>Matricule:</dt>
					<dd>3382</dd>
					<dt>Courriel:</dt>
					<dd>francois.poitras@umontreal.ca</dd>
					<dt>Temps mis:</dt>
					<dd>20 heures</dd>
				</dl>
			</div>
		</div>

		<div>
			<h2>Distribution des tâches</h2>

			<table cellpadding="7px">
				<thead>
					<tr>
						<th class="first_col">
							Tâche
						</th>
						<th>
							Félix
						</th>
						<th>
							Gevrai
						</th>
						<th>
							Charles
						</th>
						<th>
							François
						</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td class="first_col">
							Design
						</td>
						<td>
							Discuter trop longtemps de comment gérer les patrons
						</td>
						<td>
							Discuter trop longtemps de comment gérer les patrons,
							Être méticuleux et rendre le tout visuellement potable,
                            DSS
						</td>
						<td>Discuter trop longtemps de comment gérer les patrons, patron de Commande</td>
						<td>Discuter trop longtemps de comment gérer les patrons, DSS</td>
					</tr>
					<tr>
						<td class="first_col">Code</td>
						<td>GUI, arriver à compiler pour patron de Commande et Médiateurs, readme</td>
						<td>Génération du code, implantation des paquets Travel et Utils, patron Visiteur, État, Observateur et Fabrique. Tests et création des objets de bases</td>
		                <td>Paquets "Commands", "CommandMediators"</td>
						<td>Correction de bugs, Forms (partiellement)</td>
					</tr>
					<tr>
						<td class="first_col">Autres</td>

						<td>Mise en page du rapport, réseau de Pétri, discussion sur la qualité</td>

						<td> Sommaires discussions des patrons</td>
						<td></td>
						<td></td>
					</tr>

				</tbody>
			</table>

		</div>
		<h2>Hypothèses</h2>
		<ul>
			<li>Considérant que les patrons sont très adaptables, certains ont été modifiés en conséquence, mais demeurent tout de même fidèles au patron de base.</li>
                        <li>Le focus a été mis sur le design et l'implantation. Considérant l'ampleur de la tâche, le système n'a pas pu être complétée intégralement.</li>
		</ul>
		<h2 id="diag">Design logiciel</h2>
    <p>Le fichier principal est <a href="./Design/design.vpp">ici</a></p>
    <p>Le git est <a href="https://github.com/msieurmoustache/ift3911/graphs/contributors">ici</a></p>
    <h3>Diagramme complet</h3>
    <img src="./images/diagrammeconceptuel.png" alt="diagramme de classes">

		<h3>Patrons de conceptions</h3>
    <h4>Commande</h4>
		<img src="./images/SequenceCommand.png" alt="dss commande">
		<img src="./images/ClassDiagramCommand.png" alt="classes commande">

    <h4>Fabrique et Singleton</h4>
    <p>Fonctionnel à 90% dans le code: Ne fait potentiellement pas toutes les vérifications des objets créés, mais utilisable </p>
    <img src="./images/SequenceFactory.png" alt="dss fabrique">
    <img src="./images/ClassDiagramFactory.png" alt="classes fabrique">

    <h4>Observateur</h4>
    <p>Implémenté mais pas appliqué dans le code.</p>
    <p>Nous avons choisi de d'implanter l'Observateur entre le système (représenté par la session) et l'interface utilisateur. Il aurait été possible de définir chaque objets du système (Trip, Company, Itinerary, etc.) comme sujet, mais dans ce cas lors de la création d'un nouvel objet aucun observateur n'y est connecté et ainsi aucun changement ne se propagerait aux interfaces. Notre sujets maintenant est en quelque sorte le système lui-même, qui notifie les utilisateurs dès qu'un changement est effectué</p>
    <img src="./images/SequenceObserver.png" alt="dss observateur">
    <img src="./images/ClassDiagramObserver.png" alt="classes observateur">

    <h4>État</h4>
    <p>Implémenté et appliqué aux 'Reservables' avec en plus un Timer de 24h sur l'état Assigned</p>
    <img src="./images/SequenceEtat.png" alt="dss etat">
    <img src="./images/ClassDiagramEtat.png" alt="classes etat">

    <h4>Visiteur</h4>
    <p>Implémenté pour tous les types de Trip, pour les Admins et Clients.</p>
    <img src="./images/ClassDiagramVisitor.png" alt="classes visiteur">

		<h3>Diagramme de paquets</h3>
    <img src="./images/PackageDiagram.png" alt="communication fabrique">

		<h2 id="qual">Discussion sur la qualité</h2>
    <h3>Graphe IA</h3>

    <figure>
        <img src="./qual/iaDM2.png" alt="" />
        <figcaption>Graphe IA du DM2</figcaption>
    </figure>
    <figure>
        <img src="./qual/iaDM3.png" alt="" />
        <figcaption>Graphe IA du DM3</figcaption>
    </figure>

    <p>
			  Par rapport au graphe IA, le design précédent ne semblait pas montrer de grandes problématiques au niveau du design. Pour ce design-ci, l'analyse d'un tel graphe nous a forcé à nous pencher sur
        plusieurs paquets qui se retrouvaient dans la zone de la douleur. Deux paquets, Travel.Itineries et Travel.Facilities, faisaient partie de ce lot et nous avons remarqué qu'ils étaient étroitement couplés avec Trip,
        mais rien d'autres. Notre solution a été de fusionné les paquets, puisque ces éléments n'avaient pas de sens les uns sans les autres. Si on compare les deux graphes, on constate premièrement
        que le nombre de paquets est beaucoup plus grand. On voit aussi que plusieurs paquets ne sont pas du tout abstraits. En l'occurence, ce sont les paquets Application, Commands, Travel.Forms,
        Travel. et Travel.Factories qui ne possèdent aucune abstraction. On peut également constater que certains points n'ont bouger, ce sont les rares paquets qui n'ont pas subis de modification, tels que Travel.Place
        et Travel.Vehicle. Globalement, on constate que le degré d'abstraction a diminué, de même que le degré d'indépendance, ce qui nous laisse avec un design assez bon, mais plus difficile à implémenter comparativement
        au précédent.
		</p>
    <p>
        L'application des patrons de conception s'est montrée très efficace sur le plan du ratio IA, particulièrement le patron de Commande qui crée un paquet très dépendant avec un seul point
        d'entré par l'utilisation de l'invocateur. Nous avons également ajouté un paquet Application qui est invoqué par la main. Celle-ci sert d'initialisateur principal et sert de lien entre l'UI et
        le reste du logiciel. De cette façon, Toute forme d'UI peut facilement être remplacé, car il n'y a aucune dépendance directe.
    </p>
    <p>
        Notre design est un bon exemple du SRP, en général, les méthodes n'ont qu'un point d'accès et font un nombre de choses limitées. La plus grande cause de l'enflement du nombre de classes, mise à part
        les patrons de conceptions, est la séparation de nos classes pour réduire la responsabilité de chacune. À ce titre, le patron de commande est encore une fois merveilleux pour créer des
        controlleurs simples et conserver un faible couplage. Les interfaces que nous utilisions précédemment sont encore présentes et, par leurs responsabilités limitées dès le départ, nous n'avons
        pas usé du ISP pour les spécialisées. Le DIP est quand même respecté sur ce plan, car la plupart de nos liens de dépendances sont vers les classes abstraites de nos paquets et les versions concrètes
        sont gérées à partir des Fabriques, ce qui fait en sorte que les dépendances ne sont presque jamais concrètes dans l'entièreté du logiciel. Cela donne un design assez flexible et facilement extensible.
        Les Fabriques font d'ailleurs en sorte qu'il serait presque trivial d'ajouter un nouveau mode de transport. Avec tout ce qui est déjà présent, peu de choses auraient besoin d'être ajoutées. En respectant
        ces principes, nous respectons également le OCP, surtout avec notre soin apporté au respect du DIP.

    </p>
		<h2>Génération et implémentation</h2>
		<h2>Réseau de Pétri</h2>
    <img src="./images/pn.png">
    <p>marquage initial [k,0,k,0]. Tous les arcs sont pondérés à 1 sauf deux arcs pondérés à une constante k. </p>
    <ol>
				<li><img src="./images/gak1.png" />	Pour k=1, pour les k > 1, on aura l'option d'approfondir la branche jusqu'à ce que p1 et p3 soient égaux à 0, avec possibilité de franchir t3 à chacune des étapes de la branche pour revenir au marquage précédent.</li>

				<li>Prouvez si le réseau est borné. </li>

				<li>Déterminez la vivacité des quatre transitions. </li>
				<li>Déterminez si le réseau est conservateur.</li>

		</ol>
		<p>



        Pour n'importe quel k > 0, :</br>
        Si on regarde le AC pour k=1, on voit qu'on peut toujours retourner au marquage précédent à partir du marquage actuel. C'est également le cas pour toutes les valeurs de k subséquentes. À ce titre, le nombre de marquage possible est fonction de K+1 + |M(K-1)|, c'est à dire que M(K-1) est un sous-ensemble de M(K). On peut donc conclure est le réseau est borné, car son AC ne contient pas d'Omega peu un K de valeur quelconque.

			  Le réseau est borné, mais il n'a aucune configuration d'interblocage, ce qui lui permet de faire une infinité de transitions. À ce titre, l'ensemble des transitions sont L2-vivantes, car aucune des transitions ne peut être faite infiniment, il y a une limite à ce qu'une transition peut être faite avant de devoir passer par une autre.
			  [k,0,k,0] t2 [k-1,0,0,1]
        Le réseau est conservateur. Le vecteur vertical [1,2,1,k+1] permet d'obtenir une constante sur l'ensemble des marquages du réseau. Par exemple: <br/>
				[1,2,1,k+1] * [k,0,k,0] = k+0+k+0 = 2k <br/>
				[1,2,1,k+1] * [k-1,0,0,1] = (k-1)/2 + k-1 + 0 + 0 + k+1 = 2k

		</p>
	</main>

</body>
</html>
